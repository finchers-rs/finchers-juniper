var N = null;var searchIndex = {};
searchIndex["finchers_juniper"]={"doc":"A set of extensions for supporting Juniper integration.","items":[[0,"execute","finchers_juniper","GraphQL executors.",N,N],[3,"CurrentThread","finchers_juniper::execute","",N,N],[3,"Nonblocking","","",N,N],[3,"WithSpawner","","",N,N],[5,"current_thread","","Create a GraphQL executor from the specified `RootNode`.",N,[[["s"]],["currentthread"]]],[5,"nonblocking","","Create a GraphQL executor from the specified `RootNode`.",N,[[["s"]],["nonblocking"]]],[5,"with_spawner","","Create a GraphQL executor from the specified `RootNode` and task executor.",N,[[["s"],["sp"]],["withspawner"]]],[11,"fmt","","",0,[[["self"],["formatter"]],["result"]]],[11,"into_endpoint","","",0,N],[11,"wrap","","",0,N],[11,"fmt","","",1,[[["self"],["formatter"]],["result"]]],[11,"into_endpoint","","",1,N],[11,"wrap","","",1,N],[11,"fmt","","",2,[[["self"],["formatter"]],["result"]]],[11,"into_endpoint","","",2,N],[11,"wrap","","",2,N],[8,"Schema","","Trait representing a GraphQL schema.",N,N],[8,"SharedSchema","","A helper trait for representing a `Schema` which can be shared between threads.",N,N],[0,"graphiql","finchers_juniper","Endpoint for serving GraphiQL source.",N,N],[3,"GraphiQLSource","finchers_juniper::graphiql","",N,N],[5,"graphiql_source","","Creates an endpoint which returns a generated GraphiQL interface.",N,N],[11,"fmt","","",3,[[["self"],["formatter"]],["result"]]],[11,"regenerate","","Regenerate the GraphiQL interface with the specified endpoint URL.",3,N],[11,"apply","","",3,[[["self"],["applycontext"]],["applyresult"]]],[0,"request","finchers_juniper","Endpoint for parsing GraphQL request.",N,N],[3,"GraphQLRequestEndpoint","finchers_juniper::request","",N,N],[3,"GraphQLRequest","","A type representing the decoded GraphQL query obtained by parsing an HTTP request.",N,N],[3,"GraphQLResponse","","A type representing the result from executing a GraphQL query.",N,N],[5,"graphql_request","","Create an endpoint which parses a GraphQL request from the client.",N,[[],["graphqlrequestendpoint"]]],[11,"fmt","","",4,[[["self"],["formatter"]],["result"]]],[11,"apply","","",4,[[["self"],["applycontext"]],["applyresult"]]],[11,"fmt","","",5,[[["self"],["formatter"]],["result"]]],[11,"execute","","Executes a GraphQL query represented by this value using the specified schema and context.",5,[[["self"],["rootnode"],["ctxt"]],["graphqlresponse"]]],[11,"fmt","","",6,[[["self"],["formatter"]],["result"]]],[11,"respond","","",6,[[["self"],["outputcontext"]],["result",["response"]]]]],"paths":[[3,"CurrentThread"],[3,"Nonblocking"],[3,"WithSpawner"],[3,"GraphiQLSource"],[3,"GraphQLRequestEndpoint"],[3,"GraphQLRequest"],[3,"GraphQLResponse"]]};
searchIndex["juniper"]={"doc":"GraphQL","items":[[3,"LookAheadArgument","juniper","An argument passed into the query",N,N],[3,"LookAheadSelection","","A selection performed by a query",N,N],[3,"ExecutionError","","Error type for errors that occur during query execution",N,N],[3,"Executor","","Query execution engine",N,N],[3,"FieldError","","Error type for errors that occur during field resolution",N,N],[3,"Registry","","A type registry used to build schemas",N,N],[12,"types","","Currently registered types",0,N],[3,"RootNode","","Root query node of a schema",N,N],[3,"Arguments","","Field argument container",N,N],[3,"EmptyMutation","","Utility type to define read-only schemas",N,N],[3,"ID","","An ID as defined by the GraphQL specification",N,N],[3,"RuleError","","Query validation error",N,N],[3,"Object","","A Object value",N,N],[4,"InputValue","","A JSON-like value that can be passed into the query execution, either out-of-band, or in-band as default variable values. These are not constant and might contain variables.",N,N],[13,"Null","","",1,N],[13,"Int","","",1,N],[13,"Float","","",1,N],[13,"String","","",1,N],[13,"Boolean","","",1,N],[13,"Enum","","",1,N],[13,"Variable","","",1,N],[13,"List","","",1,N],[13,"Object","","",1,N],[4,"Selection","","Entry in a GraphQL selection set",N,N],[13,"Field","","",2,N],[13,"FragmentSpread","","",2,N],[13,"InlineFragment","","",2,N],[4,"Type","","A type literal in the syntax tree",N,N],[13,"Named","","A nullable named type, e.g. `String`",3,N],[13,"List","","A nullable list type, e.g. `[String]`",3,N],[13,"NonNullNamed","","A non-null named type, e.g. `String!`",3,N],[13,"NonNullList","","A non-null list type, e.g. `[String]!`.",3,N],[4,"Applies","","An enum that describes if a field is available in all types of the interface or only in a certain subtype",N,N],[13,"All","","The field is available independent from the type",4,N],[13,"OnlyType","","The field is only available for a given typename",4,N],[4,"LookAheadValue","","A JSON-like value that can is used as argument in the query execution",N,N],[13,"Null","","",5,N],[13,"Int","","",5,N],[13,"Float","","",5,N],[13,"String","","",5,N],[13,"Boolean","","",5,N],[13,"Enum","","",5,N],[13,"List","","",5,N],[13,"Object","","",5,N],[4,"TypeKind","","GraphQL type kind",N,N],[13,"Scalar","","Scalar types",6,N],[13,"Object","","Object types",6,N],[13,"Interface","","Interface types",6,N],[13,"Union","","Union types",6,N],[13,"Enum","","Enum types",6,N],[13,"InputObject","","Input objects",6,N],[13,"List","","List types",6,N],[13,"NonNull","","Non-null types",6,N],[4,"Value","","Serializable value returned from query and field execution.",N,N],[13,"Null","","",7,N],[13,"Int","","",7,N],[13,"Float","","",7,N],[13,"String","","",7,N],[13,"Boolean","","",7,N],[13,"List","","",7,N],[13,"Object","","",7,N],[4,"GraphQLError","","An error that prevented query execution",N,N],[13,"ParseError","","",8,N],[13,"ValidationError","","",8,N],[13,"NoOperationProvided","","",8,N],[13,"MultipleOperationsProvided","","",8,N],[13,"UnknownOperationName","","",8,N],[5,"execute","","Execute a query in a provided schema",N,[[["str"],["option",["str"]],["rootnode"],["variables"],["ctxt"]],["result",["graphqlerror"]]]],[11,"fmt","","",7,[[["self"],["formatter"]],["result"]]],[11,"eq","","",7,[[["self"],["value"]],["bool"]]],[11,"ne","","",7,[[["self"],["value"]],["bool"]]],[11,"clone","","",7,[[["self"]],["value"]]],[11,"fmt","","",9,[[["self"],["formatter"]],["result"]]],[11,"eq","","",9,[[["self"],["object"]],["bool"]]],[11,"ne","","",9,[[["self"],["object"]],["bool"]]],[11,"clone","","",9,[[["self"]],["object"]]],[11,"with_capacity","","Create a new Object value with a fixed number of preallocated slots for field-value pairs",9,[[["usize"]],["self"]]],[11,"add_field","","Add a new field with a value",9,[[["self"],["k"],["value"]],["option",["value"]]]],[11,"contains_field","","Check if the object already contains a field with the given name",9,[[["self"],["k"]],["bool"]]],[11,"iter","","Get a iterator over all field value pairs",9,[[["self"]],["fielditer"]]],[11,"iter_mut","","Get a iterator over all mutable field value pairs",9,[[["self"]],["fielditermut"]]],[11,"field_count","","Get the current number of fields",9,[[["self"]],["usize"]]],[11,"get_field_value","","Get the value for a given field",9,[[["self"],["k"]],["option",["value"]]]],[11,"into_iter","","",9,N],[11,"from","","",7,[[["object"]],["self"]]],[11,"from_iter","","",9,[[["i"]],["self"]]],[11,"null","","Construct a null value.",7,[[],["value"]]],[11,"int","","Construct an integer value.",7,[[["i32"]],["value"]]],[11,"float","","Construct a floating point value.",7,[[["f64"]],["value"]]],[11,"string","","Construct a string value.",7,[[["t"]],["value"]]],[11,"boolean","","Construct a boolean value.",7,[[["bool"]],["value"]]],[11,"list","","Construct a list value.",7,[[["vec",["value"]]],["value"]]],[11,"object","","Construct an object value.",7,[[["object"]],["value"]]],[11,"is_null","","Does this value represent null?",7,[[["self"]],["bool"]]],[11,"as_float_value","","View the underlying float value, if present.",7,[[["self"]],["option",["f64"]]]],[11,"as_object_value","","View the underlying object value, if present.",7,[[["self"]],["option",["object"]]]],[11,"as_mut_object_value","","Mutable view into the underlying object value, if present.",7,[[["self"]],["option",["object"]]]],[11,"as_list_value","","View the underlying list value, if present.",7,[[["self"]],["option",["vec"]]]],[11,"as_string_value","","View the underlying string value, if present.",7,[[["self"]],["option",["str"]]]],[11,"to_input_value","","",7,[[["self"]],["inputvalue"]]],[11,"from","","",7,[[["str"]],["value"]]],[11,"from","","",7,[[["string"]],["value"]]],[11,"from","","",7,[[["bool"]],["value"]]],[11,"from","","",7,[[["i32"]],["value"]]],[11,"from","","",7,[[["f64"]],["value"]]],[11,"from","","",7,[[["option"]],["value"]]],[11,"clone","","",3,[[["self"]],["type"]]],[11,"eq","","",3,[[["self"],["type"]],["bool"]]],[11,"ne","","",3,[[["self"],["type"]],["bool"]]],[11,"fmt","","",3,[[["self"],["formatter"]],["result"]]],[11,"clone","","",1,[[["self"]],["inputvalue"]]],[11,"eq","","",1,[[["self"],["inputvalue"]],["bool"]]],[11,"ne","","",1,[[["self"],["inputvalue"]],["bool"]]],[11,"fmt","","",1,[[["self"],["formatter"]],["result"]]],[11,"clone","","",2,[[["self"]],["selection"]]],[11,"eq","","",2,[[["self"],["selection"]],["bool"]]],[11,"ne","","",2,[[["self"],["selection"]],["bool"]]],[11,"fmt","","",2,[[["self"],["formatter"]],["result"]]],[11,"name","","Get the name of a named type.",3,[[["self"]],["option",["str"]]]],[11,"innermost_name","","Get the innermost name by unpacking lists",3,[[["self"]],["str"]]],[11,"is_non_null","","Determines if a type only can represent non-null values.",3,[[["self"]],["bool"]]],[11,"fmt","","",3,[[["self"],["formatter"]],["result"]]],[11,"null","","Construct a null value.",1,[[],["inputvalue"]]],[11,"int","","Construct an integer value.",1,[[["i32"]],["inputvalue"]]],[11,"float","","Construct a floating point value.",1,[[["f64"]],["inputvalue"]]],[11,"boolean","","Construct a boolean value.",1,[[["bool"]],["inputvalue"]]],[11,"string","","Construct a string value.",1,[[["t"]],["inputvalue"]]],[11,"enum_value","","Construct an enum value.",1,[[["t"]],["inputvalue"]]],[11,"variable","","Construct a variable value.",1,[[["t"]],["inputvalue"]]],[11,"list","","Construct an unlocated list.",1,[[["vec",["inputvalue"]]],["inputvalue"]]],[11,"parsed_list","","Construct a located list.",1,[[["vec",["spanning"]]],["inputvalue"]]],[11,"object","","Construct an unlocated object.",1,[[["indexmap",["inputvalue"]]],["inputvalue"]]],[11,"parsed_object","","Construct a located object.",1,[[["vec"]],["inputvalue"]]],[11,"into_const","","Resolve all variables to their values.",1,[[["self"],["variables"]],["inputvalue"]]],[11,"convert","","Shorthand form of invoking `FromInputValue::from()`.",1,[[["self"]],["option"]]],[11,"is_null","","Does the value represent null?",1,[[["self"]],["bool"]]],[11,"is_variable","","Does the value represent a variable?",1,[[["self"]],["bool"]]],[11,"as_enum_value","","View the underlying enum value, if present.",1,[[["self"]],["option",["str"]]]],[11,"as_int_value","","View the underlying int value, if present.",1,[[["self"]],["option",["i32"]]]],[11,"as_float_value","","View the underlying float value, if present.",1,[[["self"]],["option",["f64"]]]],[11,"as_string_value","","View the underlying string value, if present.",1,[[["self"]],["option",["str"]]]],[11,"to_object_value","","Convert the input value to an unlocated object value.",1,[[["self"]],["option",["indexmap"]]]],[11,"to_list_value","","Convert the input value to an unlocated list value.",1,[[["self"]],["option",["vec"]]]],[11,"referenced_variables","","Recursively find all variables",1,[[["self"]],["vec",["str"]]]],[11,"unlocated_eq","","Compare equality with another `InputValue` ignoring any source position information.",1,[[["self"],["inputvalue"]],["bool"]]],[11,"fmt","","",1,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",4,[[["self"],["formatter"]],["result"]]],[11,"clone","","",4,[[["self"]],["applies"]]],[11,"eq","","",4,[[["self"],["applies"]],["bool"]]],[11,"ne","","",4,[[["self"],["applies"]],["bool"]]],[11,"fmt","","",5,[[["self"],["formatter"]],["result"]]],[11,"clone","","",5,[[["self"]],["lookaheadvalue"]]],[11,"eq","","",5,[[["self"],["lookaheadvalue"]],["bool"]]],[11,"ne","","",5,[[["self"],["lookaheadvalue"]],["bool"]]],[11,"fmt","","",10,[[["self"],["formatter"]],["result"]]],[11,"clone","","",10,[[["self"]],["lookaheadargument"]]],[11,"eq","","",10,[[["self"],["lookaheadargument"]],["bool"]]],[11,"ne","","",10,[[["self"],["lookaheadargument"]],["bool"]]],[11,"value","","The value of the argument",10,[[["self"]],["lookaheadvalue"]]],[11,"fmt","","",11,[[["self"],["formatter"]],["result"]]],[11,"clone","","",11,[[["self"]],["lookaheadselection"]]],[11,"eq","","",11,[[["self"],["lookaheadselection"]],["bool"]]],[11,"ne","","",11,[[["self"],["lookaheadselection"]],["bool"]]],[11,"for_explicit_type","","Convert a eventually type independent selection into one for a concrete type",11,[[["self"],["str"]],["concretelookaheadselection"]]],[11,"field_name","","",11,[[["self"]],["str"]]],[11,"select_child","","",11,[[["self"],["str"]],["option"]]],[11,"arguments","","",11,N],[11,"fmt","","",12,[[["self"],["formatter"]],["result"]]],[11,"eq","","",12,[[["self"],["executionerror"]],["bool"]]],[11,"ne","","",12,[[["self"],["executionerror"]],["bool"]]],[11,"at_origin","","Construct a new execution error occuring at the beginning of the query",12,[[["fielderror"]],["executionerror"]]],[11,"partial_cmp","","",12,[[["self"],["executionerror"]],["option",["ordering"]]]],[11,"cmp","","",12,[[["self"],["executionerror"]],["ordering"]]],[11,"fmt","","",13,[[["self"],["formatter"]],["result"]]],[11,"eq","","",13,[[["self"],["fielderror"]],["bool"]]],[11,"ne","","",13,[[["self"],["fielderror"]],["bool"]]],[11,"from","","",13,[[["t"]],["fielderror"]]],[11,"new","","Construct a new error with additional data",13,[[["t"],["value"]],["fielderror"]]],[11,"into_field_error","","",13,[[["self"]],["fielderror"]]],[11,"resolve_with_ctx","","Resolve a single arbitrary value, mapping the context to a new type",14,N],[11,"resolve","","Resolve a single arbitrary value into an `ExecutionResult`",14,N],[11,"resolve_into_value","","Resolve a single arbitrary value into a return value",14,N],[11,"replaced_context","","Derive a new executor by replacing the context",14,[[["self"],["newctxt"]],["executor"]]],[11,"context","","Access the current context",14,[[["self"]],["ctxt"]]],[11,"schema","","The currently executing schema",14,[[["self"]],["schematype"]]],[11,"location","","The current location of the executor",14,[[["self"]],["sourceposition"]]],[11,"push_error","","Add an error to the execution engine at the current executor location",14,[[["self"],["fielderror"]]]],[11,"push_error_at","","Add an error to the execution engine at a specific location",14,[[["self"],["fielderror"],["sourceposition"]]]],[11,"look_ahead","","Construct a lookahead selection for the current selection",14,[[["self"]],["lookaheadselection"]]],[11,"error","","The error message",12,[[["self"]],["fielderror"]]],[11,"location","","The source location in the query of the field that failed to resolve",12,[[["self"]],["sourceposition"]]],[11,"path","","The path of fields leading to the field that generated this error",12,N],[11,"new","","Construct a new registry",0,[[["fnvhashmap",["name","metatype"]]],["registry"]]],[11,"get_type","","Get the `Type` instance for a given GraphQL type",0,N],[11,"field","","Create a field with the provided name",0,N],[11,"arg","","Create an argument with the provided name",0,N],[11,"arg_with_default","","Create an argument with a default value",0,N],[11,"build_scalar_type","","Create a scalar meta type",0,N],[11,"build_list_type","","Create a list meta type",0,N],[11,"build_nullable_type","","Create a nullable meta type",0,N],[11,"build_object_type","","Create an object meta type builder",0,N],[11,"build_enum_type","","Create an enum meta type",0,N],[11,"build_interface_type","","Create an interface meta type builder, by providing a type info object.",0,N],[11,"build_union_type","","Create a union meta type builder",0,N],[11,"build_input_object_type","","Create an input object meta type builder",0,N],[0,"parser","","Query parser and language utilities",N,N],[3,"SourcePosition","juniper::parser","A reference to a line and column in an input source file",N,N],[3,"Spanning","","Data structure used to wrap items with start and end markers in the input source",N,N],[12,"item","","The wrapped item",15,N],[12,"start","","Start position of the item",15,N],[12,"end","","End position of the item",15,N],[4,"LexerError","","Error when tokenizing the input source",N,N],[13,"UnknownCharacter","","An unknown character was found",16,N],[13,"UnexpectedCharacter","","An unexpected character was found",16,N],[13,"UnterminatedString","","An unterminated string literal was found",16,N],[13,"UnknownCharacterInString","","An unknown character in a string literal was found",16,N],[13,"UnknownEscapeSequence","","An unknown escape sequence in a string literal was found",16,N],[13,"UnexpectedEndOfFile","","The input source was unexpectedly terminated",16,N],[13,"InvalidNumber","","An invalid number literal was found",16,N],[4,"Token","","A single token in the input source",N,N],[13,"Name","","",17,N],[13,"Int","","",17,N],[13,"Float","","",17,N],[13,"String","","",17,N],[13,"ExclamationMark","","",17,N],[13,"Dollar","","",17,N],[13,"ParenOpen","","",17,N],[13,"ParenClose","","",17,N],[13,"BracketOpen","","",17,N],[13,"BracketClose","","",17,N],[13,"CurlyOpen","","",17,N],[13,"CurlyClose","","",17,N],[13,"Ellipsis","","",17,N],[13,"Colon","","",17,N],[13,"Equals","","",17,N],[13,"At","","",17,N],[13,"Pipe","","",17,N],[13,"EndOfFile","","",17,N],[4,"ParseError","","Error while parsing a GraphQL query",N,N],[13,"UnexpectedToken","","An unexpected token occurred in the source",18,N],[13,"UnexpectedEndOfFile","","The input source abruptly ended",18,N],[13,"LexerError","","An error during tokenization occurred",18,N],[11,"fmt","","",17,[[["self"],["formatter"]],["result"]]],[11,"eq","","",17,[[["self"],["token"]],["bool"]]],[11,"ne","","",17,[[["self"],["token"]],["bool"]]],[11,"fmt","","",16,[[["self"],["formatter"]],["result"]]],[11,"eq","","",16,[[["self"],["lexererror"]],["bool"]]],[11,"ne","","",16,[[["self"],["lexererror"]],["bool"]]],[11,"fmt","","",17,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",16,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",18,[[["self"],["formatter"]],["result"]]],[11,"eq","","",18,[[["self"],["parseerror"]],["bool"]]],[11,"ne","","",18,[[["self"],["parseerror"]],["bool"]]],[11,"fmt","","",18,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",19,[[["self"],["formatter"]],["result"]]],[11,"clone","","",19,[[["self"]],["sourceposition"]]],[11,"eq","","",19,[[["self"],["sourceposition"]],["bool"]]],[11,"ne","","",19,[[["self"],["sourceposition"]],["bool"]]],[11,"partial_cmp","","",19,[[["self"],["sourceposition"]],["option",["ordering"]]]],[11,"lt","","",19,[[["self"],["sourceposition"]],["bool"]]],[11,"le","","",19,[[["self"],["sourceposition"]],["bool"]]],[11,"gt","","",19,[[["self"],["sourceposition"]],["bool"]]],[11,"ge","","",19,[[["self"],["sourceposition"]],["bool"]]],[11,"cmp","","",19,[[["self"],["sourceposition"]],["ordering"]]],[11,"hash","","",19,N],[11,"fmt","","",15,[[["self"],["formatter"]],["result"]]],[11,"map","","Modify the contents of the spanned item",15,[[["self"],["f"]],["spanning"]]],[11,"clone","","",15,[[["self"]],["self"]]],[11,"eq","","",15,[[["self"],["self"]],["bool"]]],[11,"hash","","",15,[[["self"],["h"]]]],[11,"index","","The index of the character in the input source",19,[[["self"]],["usize"]]],[11,"line","","The line of the character in the input source",19,[[["self"]],["usize"]]],[11,"column","","The column of the character in the input source",19,[[["self"]],["usize"]]],[11,"new","juniper","Construct a new root node from query and mutation nodes",20,[[["queryt"],["mutationt"]],["rootnode"]]],[11,"new_with_info","","Construct a new root node from query and mutation nodes, while also providing type info objects for the query and mutation types.",20,N],[11,"name","","",20,N],[11,"meta","","",20,N],[11,"resolve_field","","",20,N],[11,"resolve","","",20,N],[11,"clone","","",6,[[["self"]],["typekind"]]],[11,"eq","","",6,[[["self"],["typekind"]],["bool"]]],[11,"fmt","","",6,[[["self"],["formatter"]],["result"]]],[11,"get","","Get and convert an argument into the desired type.",21,[[["self"],["str"]],["option"]]],[11,"clone","","",22,[[["self"]],["id"]]],[11,"fmt","","",22,[[["self"],["formatter"]],["result"]]],[11,"eq","","",22,[[["self"],["id"]],["bool"]]],[11,"ne","","",22,[[["self"],["id"]],["bool"]]],[11,"from","","",22,[[["string"]],["id"]]],[11,"deref","","",22,[[["self"]],["str"]]],[11,"name","","",22,N],[11,"meta","","",22,N],[11,"resolve","","",22,N],[11,"to_input_value","","",22,[[["self"]],["inputvalue"]]],[11,"from_input_value","","",22,[[["inputvalue"]],["option",["id"]]]],[11,"new","","Construct a new empty mutation",23,[[],["emptymutation"]]],[11,"name","","",23,N],[11,"meta","","",23,N],[11,"fmt","","",24,[[["self"],["formatter"]],["result"]]],[11,"eq","","",24,[[["self"],["ruleerror"]],["bool"]]],[11,"ne","","",24,[[["self"],["ruleerror"]],["bool"]]],[11,"partial_cmp","","",24,[[["self"],["ruleerror"]],["option",["ordering"]]]],[11,"lt","","",24,[[["self"],["ruleerror"]],["bool"]]],[11,"le","","",24,[[["self"],["ruleerror"]],["bool"]]],[11,"gt","","",24,[[["self"],["ruleerror"]],["bool"]]],[11,"ge","","",24,[[["self"],["ruleerror"]],["bool"]]],[11,"cmp","","",24,[[["self"],["ruleerror"]],["ordering"]]],[11,"message","","Access the message for a validation error",24,[[["self"]],["str"]]],[11,"locations","","Access the positions of the validation error",24,N],[0,"http","","Utilities for building HTTP endpoints in a library-agnostic manner",N,N],[3,"GraphQLRequest","juniper::http","The expected structure of the decoded JSON document for either POST or GET requests.",N,N],[3,"GraphQLResponse","","Simple wrapper around the result from executing a GraphQL query",N,N],[0,"graphiql","","Utility module to generate a GraphiQL interface",N,N],[5,"graphiql_source","juniper::http::graphiql","Generate the HTML source to show a GraphiQL interface",N,[[["str"]],["string"]]],[0,"tests","juniper::http","",N,N],[3,"TestResponse","juniper::http::tests","Normalized response content we expect to get back from the http framework integration we are testing.",N,N],[12,"status_code","","",25,N],[12,"body","","",25,N],[12,"content_type","","",25,N],[5,"run_http_test_suite","","",N,[[["t"]]]],[8,"HTTPIntegration","","Normalized way to make requests to the http framework integration we are testing.",N,N],[10,"get","","",26,[[["self"],["str"]],["testresponse"]]],[10,"post","","",26,[[["self"],["str"],["str"]],["testresponse"]]],[11,"fmt","","",25,[[["self"],["formatter"]],["result"]]],[11,"clone","juniper::http","",27,[[["self"]],["graphqlrequest"]]],[11,"eq","","",27,[[["self"],["graphqlrequest"]],["bool"]]],[11,"ne","","",27,[[["self"],["graphqlrequest"]],["bool"]]],[11,"fmt","","",27,[[["self"],["formatter"]],["result"]]],[11,"new","","Construct a new GraphQL request from parts",27,[[["string"],["option",["string"]],["option",["inputvalue"]]],["graphqlrequest"]]],[11,"execute","","Execute a GraphQL request using the specified schema and context",27,[[["self"],["rootnode"],["ctxt"]],["graphqlresponse"]]],[11,"error","","Constructs an error response outside of the normal execution flow",28,[[["fielderror"]],["self"]]],[11,"is_ok","","Was the request successful or not?",28,[[["self"]],["bool"]]],[11,"serialize","","",28,[[["self"],["s"]],["result"]]],[0,"integrations","juniper","Provides GraphQLType implementations for some external types",N,N],[11,"serialize","","",12,[[["self"],["s"]],["result"]]],[11,"serialize","","",8,[[["self"],["s"]],["result"]]],[11,"deserialize","","",1,[[["d"]],["result",["inputvalue"]]]],[11,"serialize","","",1,[[["self"],["s"]],["result"]]],[11,"serialize","","",24,[[["self"],["s"]],["result"]]],[11,"serialize","juniper::parser","",19,[[["self"],["s"]],["result"]]],[11,"serialize","","",15,[[["self"],["s"]],["result"]]],[11,"serialize","juniper","",9,[[["self"],["s"]],["result"]]],[11,"serialize","","",7,[[["self"],["s"]],["result"]]],[0,"chrono","juniper::integrations","GraphQL support for chrono types. # Supported types",N,N],[0,"url","","GraphQL support for url types.",N,N],[0,"uuid","","GraphQL support for uuid types.",N,N],[0,"tests","juniper","Library tests and fixtures",N,N],[0,"model","juniper::tests","",N,N],[3,"Database","juniper::tests::model","",N,N],[4,"Episode","","",N,N],[13,"NewHope","","",29,N],[13,"Empire","","",29,N],[13,"Jedi","","",29,N],[8,"Character","","",N,N],[10,"id","","",30,[[["self"]],["str"]]],[10,"name","","",30,[[["self"]],["str"]]],[10,"friend_ids","","",30,N],[10,"appears_in","","",30,N],[10,"secret_backstory","","",30,[[["self"]],["option"]]],[10,"as_character","","",30,[[["self"]],["character"]]],[8,"Human","","",N,N],[10,"home_planet","","",31,[[["self"]],["option"]]],[8,"Droid","","",N,N],[10,"primary_function","","",32,[[["self"]],["option"]]],[11,"clone","","",29,[[["self"]],["episode"]]],[11,"eq","","",29,[[["self"],["episode"]],["bool"]]],[11,"fmt","","",29,[[["self"],["formatter"]],["result"]]],[11,"new","","",33,[[],["database"]]],[11,"get_hero","","",33,[[["self"],["option",["episode"]]],["character"]]],[11,"get_human","","",33,[[["self"],["str"]],["option",["human"]]]],[11,"get_droid","","",33,[[["self"],["str"]],["option",["droid"]]]],[11,"get_character","","",33,[[["self"],["str"]],["option",["character"]]]],[11,"get_friends","","",33,[[["self"],["character"]],["vec",["character"]]]],[11,"name","","",33,N],[11,"meta","","",33,N],[11,"concrete_type_name","","",33,N],[11,"resolve_field","","",33,N],[0,"meta","juniper","Types used to describe a `GraphQL` schema",N,N],[3,"ScalarMeta","juniper::meta","Scalar type metadata",N,N],[3,"ListMeta","","List type metadata",N,N],[3,"NullableMeta","","Nullable type metadata",N,N],[3,"ObjectMeta","","Object type metadata",N,N],[3,"EnumMeta","","Enum type metadata",N,N],[3,"InterfaceMeta","","Interface type metadata",N,N],[3,"UnionMeta","","Union type metadata",N,N],[3,"InputObjectMeta","","Input object metadata",N,N],[3,"PlaceholderMeta","","A placeholder for not-yet-registered types",N,N],[3,"Field","","Metadata for a field",N,N],[3,"Argument","","Metadata for an argument to a field",N,N],[3,"EnumValue","","Metadata for a single value in an enum",N,N],[12,"name","","The name of the enum value",34,N],[12,"description","","The optional description of the enum value.",34,N],[12,"deprecation_reason","","The optional deprecation reason",34,N],[4,"MetaType","","Generic type metadata",N,N],[6,"ExecutionResult","juniper","The result of resolving an unspecified field",N,N],[6,"FieldResult","","The result of resolving the value of a field of type `T`",N,N],[6,"Variables","","The map of variables used for substitution during query execution",N,N],[8,"FromInputValue","","Parse an unstructured input value into a Rust data type.",N,N],[10,"from_input_value","","Performs the conversion.",35,[[["inputvalue"]],["option"]]],[8,"ToInputValue","","Losslessly clones a Rust data type into an InputValue.",N,N],[10,"to_input_value","","Performs the conversion.",36,[[["self"]],["inputvalue"]]],[8,"LookAheadMethods","","A set of common methods for `ConcreteLookAheadSelection` and `LookAheadSelection`",N,N],[10,"field_name","","Get the name of the field represented by the current selection",37,[[["self"]],["str"]]],[10,"select_child","","Get the the child selection for a given field",37,[[["self"],["str"]],["option"]]],[11,"has_child","","Check if a given field exists",37,[[["self"],["str"]],["bool"]]],[10,"arguments","","Get the top level arguments for the current selection",37,N],[11,"argument","","Get the top level argument with a given name from the current selection",37,[[["self"],["str"]],["option",["lookaheadargument"]]]],[8,"Context","","Marker trait for types that can act as context objects for `GraphQL` types.",N,N],[8,"FromContext","","Conversion trait for context types",N,N],[10,"from","","Perform the conversion",38,[[["t"]],["self"]]],[8,"IntoFieldError","","Custom error handling trait to enable Error types other than `FieldError` to be specified as return value.",N,N],[8,"GraphQLType","","Primary trait used to expose Rust types in a GraphQL schema",N,N],[16,"Context","","The expected context type for this GraphQL type",39,N],[16,"TypeInfo","","Type that may carry additional schema information",39,N],[10,"name","","The name of the GraphQL type to expose.",39,N],[10,"meta","","The meta type representing this GraphQL type.",39,N],[11,"resolve_field","","Resolve the value of a single field on this type.",39,N],[11,"resolve_into_type","","Resolve this interface or union into a concrete type",39,N],[11,"concrete_type_name","","Return the concrete type name for this instance/union.",39,N],[11,"resolve","","Resolve the provided selection set against the current object.",39,N],[11,"fmt","","",8,[[["self"],["formatter"]],["result"]]],[11,"eq","","",8,[[["self"],["graphqlerror"]],["bool"]]],[11,"ne","","",8,[[["self"],["graphqlerror"]],["bool"]]],[11,"from","","",8,[[["spanning",["parseerror"]]],["graphqlerror"]]],[14,"graphql_value","","Construct JSON-like values by using JSON syntax",N,N],[14,"graphql_object","","Expose GraphQL objects",N,N],[14,"graphql_interface","","Expose GraphQL interfaces",N,N],[14,"graphql_scalar","","Expose GraphQL scalars",N,N],[14,"graphql_union","","Expose GraphQL unions",N,N],[11,"has_child","","Check if a given field exists",37,[[["self"],["str"]],["bool"]]],[11,"argument","","Get the top level argument with a given name from the current selection",37,[[["self"],["str"]],["option",["lookaheadargument"]]]],[11,"fmt","juniper::meta","",40,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",41,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",42,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",43,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",44,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",45,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",46,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",47,[[["self"],["formatter"]],["result"]]],[11,"clone","","",47,[[["self"]],["field"]]],[11,"fmt","","",48,[[["self"],["formatter"]],["result"]]],[11,"clone","","",48,[[["self"]],["argument"]]],[11,"fmt","","",34,[[["self"],["formatter"]],["result"]]],[11,"clone","","",34,[[["self"]],["enumvalue"]]],[11,"name","","Access the name of the type, if applicable",46,[[["self"]],["option",["str"]]]],[11,"description","","Access the description of the type, if applicable",46,[[["self"]],["option",["string"]]]],[11,"type_kind","","Construct a `TypeKind` for a given type",46,[[["self"]],["typekind"]]],[11,"field_by_name","","Access a field's meta data given its name",46,[[["self"],["str"]],["option",["field"]]]],[11,"input_field_by_name","","Access an input field's meta data given its name",46,[[["self"],["str"]],["option",["argument"]]]],[11,"as_type","","Construct a `Type` literal instance based on the metadata",46,[[["self"]],["type"]]],[11,"input_value_parse_fn","","Access the input value parse function, if applicable",46,[[["self"]],["option",["box"]]]],[11,"is_composite","","Returns true if the type is a composite type",46,[[["self"]],["bool"]]],[11,"is_leaf","","Returns true if the type can occur in leaf positions in queries",46,[[["self"]],["bool"]]],[11,"is_abstract","","Returns true if the type is abstract",46,[[["self"]],["bool"]]],[11,"is_input","","Returns true if the type can be used in input positions, e.g. arguments or variables",46,[[["self"]],["bool"]]],[11,"new","","Build a new scalar type metadata with the specified name",49,[[["cow",["str"]]],["scalarmeta"]]],[11,"description","","Set the description for the given scalar type",49,[[["self"],["str"]],["scalarmeta"]]],[11,"into_meta","","Wrap the scalar in a generic meta type",49,[[["self"]],["metatype"]]],[11,"new","","Build a new list type by wrapping the specified type",40,[[["type"]],["listmeta"]]],[11,"into_meta","","Wrap the list in a generic meta type",40,[[["self"]],["metatype"]]],[11,"new","","Build a new nullable type by wrapping the specified type",41,[[["type"]],["nullablemeta"]]],[11,"into_meta","","Wrap the nullable type in a generic meta type",41,[[["self"]],["metatype"]]],[11,"new","","Build a new object type with the specified name and fields",42,N],[11,"description","","Set the description for the object",42,[[["self"],["str"]],["objectmeta"]]],[11,"interfaces","","Set the interfaces this type implements",42,N],[11,"into_meta","","Wrap this object type in a generic meta type",42,[[["self"]],["metatype"]]],[11,"new","","Build a new enum type with the specified name and possible values",50,N],[11,"description","","Set the description of the type",50,[[["self"],["str"]],["enummeta"]]],[11,"into_meta","","Wrap this enum type in a generic meta type",50,[[["self"]],["metatype"]]],[11,"new","","Build a new interface type with the specified name and fields",43,N],[11,"description","","Set the description of the type",43,[[["self"],["str"]],["interfacemeta"]]],[11,"into_meta","","Wrap this interface type in a generic meta type",43,[[["self"]],["metatype"]]],[11,"new","","Build a new union type with the specified name and possible types",44,N],[11,"description","","Set the description of the type",44,[[["self"],["str"]],["unionmeta"]]],[11,"into_meta","","Wrap this union type in a generic meta type",44,[[["self"]],["metatype"]]],[11,"new","","Build a new input type with the specified name and input fields",51,N],[11,"description","","Set the description of the type",51,[[["self"],["str"]],["inputobjectmeta"]]],[11,"into_meta","","Wrap this union type in a generic meta type",51,[[["self"]],["metatype"]]],[11,"description","","Set the description of the field",47,[[["self"],["str"]],["field"]]],[11,"argument","","Add an argument to the field",47,[[["self"],["argument"]],["field"]]],[11,"deprecated","","Set the deprecation reason",47,[[["self"],["str"]],["field"]]],[11,"description","","Set the description of the argument",48,[[["self"],["str"]],["argument"]]],[11,"default_value","","Set the default value of the argument",48,[[["self"],["inputvalue"]],["argument"]]],[11,"new","","Construct a new enum value with the provided name",34,[[["str"]],["enumvalue"]]],[11,"description","","Set the description of the enum value",34,[[["self"],["str"]],["enumvalue"]]],[11,"deprecated","","Set the deprecation reason for the enum value",34,[[["self"],["str"]],["enumvalue"]]],[11,"fmt","","",49,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",50,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",51,[[["self"],["formatter"]],["result"]]],[11,"name","","",47,N],[11,"meta","","",47,N],[11,"concrete_type_name","","",47,N],[11,"resolve_field","","",47,N],[11,"name","","",48,N],[11,"meta","","",48,N],[11,"concrete_type_name","","",48,N],[11,"resolve_field","","",48,N],[11,"name","","",34,N],[11,"meta","","",34,N],[11,"concrete_type_name","","",34,N],[11,"resolve_field","","",34,N],[11,"resolve_field","juniper","Resolve the value of a single field on this type.",39,N],[11,"resolve_into_type","","Resolve this interface or union into a concrete type",39,N],[11,"concrete_type_name","","Return the concrete type name for this instance/union.",39,N],[11,"resolve","","Resolve the provided selection set against the current object.",39,N]],"paths":[[3,"Registry"],[4,"InputValue"],[4,"Selection"],[4,"Type"],[4,"Applies"],[4,"LookAheadValue"],[4,"TypeKind"],[4,"Value"],[4,"GraphQLError"],[3,"Object"],[3,"LookAheadArgument"],[3,"LookAheadSelection"],[3,"ExecutionError"],[3,"FieldError"],[3,"Executor"],[3,"Spanning"],[4,"LexerError"],[4,"Token"],[4,"ParseError"],[3,"SourcePosition"],[3,"RootNode"],[3,"Arguments"],[3,"ID"],[3,"EmptyMutation"],[3,"RuleError"],[3,"TestResponse"],[8,"HTTPIntegration"],[3,"GraphQLRequest"],[3,"GraphQLResponse"],[4,"Episode"],[8,"Character"],[8,"Human"],[8,"Droid"],[3,"Database"],[3,"EnumValue"],[8,"FromInputValue"],[8,"ToInputValue"],[8,"LookAheadMethods"],[8,"FromContext"],[8,"GraphQLType"],[3,"ListMeta"],[3,"NullableMeta"],[3,"ObjectMeta"],[3,"InterfaceMeta"],[3,"UnionMeta"],[3,"PlaceholderMeta"],[4,"MetaType"],[3,"Field"],[3,"Argument"],[3,"ScalarMeta"],[3,"EnumMeta"],[3,"InputObjectMeta"]]};
initSearch(searchIndex);
